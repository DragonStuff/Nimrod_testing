/* Generated by Nimrod Compiler v0.9.4 */
/*   (c) 2014 Andreas Rumpf */
/* The generated code is subject to the original license. */
/* Compiled for: Windows, amd64, gcc */
/* Command for C compiler:
   "C:\Program Files (x86)\Nimrod\dist\mingw\bin\gcc.exe" -c  -w  -I"C:\Program Files (x86)\Nimrod\lib" -o c:\users\androiddev\documents\github\nimrod_testing\nimcache\procedures.o c:\users\androiddev\documents\github\nimrod_testing\nimcache\procedures.c */
#define NIM_INTBITS 64
#include "nimbase.h"

#include <stdio.h>

#include <string.h>
typedef struct NimStringDesc NimStringDesc;
typedef struct TGenericSeq TGenericSeq;
struct  TGenericSeq  {
NI len;
NI reserved;
};
struct  NimStringDesc  {
  TGenericSeq Sup;
NIM_CHAR data[SEQ_DECL_SIZE];
};
N_NIMCALL(NIM_BOOL, yes_84003)(NimStringDesc* question);
N_NIMCALL(NimStringDesc*, readline_10484)(FILE* f);
static N_INLINE(NIM_BOOL, eqStrings)(NimStringDesc* a, NimStringDesc* b);
static N_INLINE(void, nimFrame)(TFrame* s);
static N_INLINE(void, popFrame)(void);
static N_INLINE(void, initStackBottom)(void);
N_NOINLINE(void, setStackBottom)(void* thestackbottom);
N_NOINLINE(void, systemInit)(void);
N_NOINLINE(void, systemDatInit)(void);
N_NOINLINE(void, proceduresInit)(void);
N_NOINLINE(void, proceduresDatInit)(void);
STRING_LITERAL(TMP125, " (y/n)", 6);
STRING_LITERAL(TMP126, "y", 1);
STRING_LITERAL(TMP127, "Y", 1);
STRING_LITERAL(TMP128, "yes", 3);
STRING_LITERAL(TMP129, "Yes", 3);
STRING_LITERAL(TMP130, "n", 1);
STRING_LITERAL(TMP131, "N", 1);
STRING_LITERAL(TMP132, "no", 2);
STRING_LITERAL(TMP133, "No", 2);
STRING_LITERAL(TMP134, "Please be clear: yes or no", 26);
STRING_LITERAL(TMP135, "Should I delete all your important files?", 41);
STRING_LITERAL(TMP136, "I\'m sorry Dave, I\'m afraid I can\'t do that.", 43);
STRING_LITERAL(TMP137, "I think you know what the problem is just as well as I do.", 58);
extern TFrame* frameptr_13038;

static N_INLINE(NIM_BOOL, eqStrings)(NimStringDesc* a, NimStringDesc* b) {
	NIM_BOOL result;
	NIM_BOOL LOC11;
	int LOC13;
	result = 0;
	{
		if (!(a == b)) goto LA3;
		result = NIM_TRUE;
		goto BeforeRet;
	}
	LA3: ;
	{
		NIM_BOOL LOC7;
		LOC7 = 0;
		LOC7 = (a == NIM_NIL);
		if (LOC7) goto LA8;
		LOC7 = (b == NIM_NIL);
		LA8: ;
		if (!LOC7) goto LA9;
		result = NIM_FALSE;
		goto BeforeRet;
	}
	LA9: ;
	LOC11 = 0;
	LOC11 = ((*a).Sup.len == (*b).Sup.len);
	if (!(LOC11)) goto LA12;
	LOC13 = 0;
	LOC13 = memcmp(((NCSTRING) ((*a).data)), ((NCSTRING) ((*b).data)), (NI64)((*a).Sup.len * 1));
	LOC11 = (LOC13 == ((NI32) 0));
	LA12: ;
	result = LOC11;
	goto BeforeRet;
	BeforeRet: ;
	return result;
}

static N_INLINE(void, nimFrame)(TFrame* s) {
	(*s).prev = frameptr_13038;
	frameptr_13038 = s;
}

static N_INLINE(void, popFrame)(void) {
	frameptr_13038 = (*frameptr_13038).prev;
}

N_NIMCALL(NIM_BOOL, yes_84003)(NimStringDesc* question) {
	NIM_BOOL result;
	nimfr("yes", "procedures.nim")
	result = 0;
	nimln(2, "procedures.nim");
	printf("%s%s\015\012", (question)->data, (((NimStringDesc*) &TMP125))->data);
	nimln(3, "procedures.nim");
	while (1) {
		NimStringDesc* LOC2;
		nimln(4, "procedures.nim");
		nimln(4, "procedures.nim");
		LOC2 = 0;
		LOC2 = readline_10484(stdin);
		if (eqStrings(LOC2, ((NimStringDesc*) &TMP126))) goto LA3;
		if (eqStrings(LOC2, ((NimStringDesc*) &TMP127))) goto LA3;
		if (eqStrings(LOC2, ((NimStringDesc*) &TMP128))) goto LA3;
		if (eqStrings(LOC2, ((NimStringDesc*) &TMP129))) goto LA3;
		if (eqStrings(LOC2, ((NimStringDesc*) &TMP130))) goto LA4;
		if (eqStrings(LOC2, ((NimStringDesc*) &TMP131))) goto LA4;
		if (eqStrings(LOC2, ((NimStringDesc*) &TMP132))) goto LA4;
		if (eqStrings(LOC2, ((NimStringDesc*) &TMP133))) goto LA4;
		goto LA5;
		LA3: ;
		{
			nimln(5, "procedures.nim");
			nimln(5, "procedures.nim");
			result = NIM_TRUE;
			goto BeforeRet;
		}
		goto LA6;
		LA4: ;
		{
			nimln(6, "procedures.nim");
			nimln(6, "procedures.nim");
			result = NIM_FALSE;
			goto BeforeRet;
		}
		goto LA6;
		LA5: ;
		{
			nimln(7, "procedures.nim");
			printf("%s\015\012", (((NimStringDesc*) &TMP134))->data);
		}
		LA6: ;
	}
	BeforeRet: ;
	popFrame();
	return result;
}

static N_INLINE(void, initStackBottom)(void) {
	void* volatile locals;
	locals = 0;
	locals = ((void*) (&locals));
	setStackBottom(locals);
}
void PreMain() {
	systemDatInit();
	systemInit();
	proceduresDatInit();
	initStackBottom();
}

int cmdCount;
char** cmdLine;
char** gEnv;
N_CDECL(void, NimMain)(void) {
	PreMain();
	proceduresInit();
}

int main(int argc, char** args, char** env) {
	cmdLine = args;
	cmdCount = argc;
	gEnv = env;
	NimMain();
	return nim_program_result;
}

N_NOINLINE(void, proceduresInit)(void) {
	nimfr("procedures", "procedures.nim")
	nimln(9, "procedures.nim");
	{
		NIM_BOOL LOC3;
		nimln(9, "procedures.nim");
		LOC3 = 0;
		LOC3 = yes_84003(((NimStringDesc*) &TMP135));
		if (!LOC3) goto LA4;
		nimln(10, "procedures.nim");
		printf("%s\015\012", (((NimStringDesc*) &TMP136))->data);
	}
	goto LA1;
	LA4: ;
	{
		nimln(12, "procedures.nim");
		printf("%s\015\012", (((NimStringDesc*) &TMP137))->data);
	}
	LA1: ;
	popFrame();
}

N_NOINLINE(void, proceduresDatInit)(void) {
}

